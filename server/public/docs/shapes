//Shapes describe collision geometry and may be used 
// independently of physics simulation. 
// each shape has a type member...	//  and each type has a radius

		//Box2D shape ops:
		//- Test a point for overlap with the shape.
		//-Perform a ray cast against the shape.
		//-Compute the shape's AABB.
		//-Compute the mass properties of the shape.
		//Circle shapes have a position 
        //  A polygon must have 3 or more vertices.
        //You must create polygons with a counter clockwise winding (CCW). 
        // We must be careful because the notion of CCW is 
        // with respect to a right-handed coordinate system 
        // with the z-axis pointing out of the plane. 
        // This might turn out to be clockwise on your screen, 
        // depending on your coordinate system conventions.
        // you should use initialization functions to create a polygon. 
        // The initialization functions create normal vectors and perform validation.
        // You can create a polygon shape by passing in a vertex array. 
        // The maximal size of the array is controlled by b2_maxPolygonVertices 
        // which has a default value of 8. 
        //This is sufficient to describe most convex polygons.
        //The radius creates a skin around the polygon.
        // The skin is used in stacking scenarios to keep polygons slightly separated. 
        // This allows continuous collision to work against the core polygon.
        //The polygon skin helps prevent tunneling by keeping the polygons separated. 
        // This results in small gaps between the shapes. 
        // Your visual representation can be larger than the polygon to hide any gaps.
        
        
        
       
       
      
	// whats up with _$pH? (will become $pH, rectangles should shift to $rH)
//$H is call sAA, which passes in arr lenght for you
//sAA just calls SetAsArray direct
//the above example started with w.D to make a dynamic body
// heres another example to show it again
//here lets look at $cF and $pF in a sec
//but first notice that w.D takes an x and y
// and then an array of fixture 'specs'
// based on how many nums in the array,
// it knows if it is a circle or rect
// we will come back to that shortcut soon and look at w.D..
// but really those shapes are converted to fixtures and it can be seen that
// it takes fixtures directly, probably it's main way to handle things..
//$cF makes a fixt from a $cH
//pass '-' to get a sensor!
//$cH can take radius and x,y position as well..
//radius defaults to 50, and x,y default to 0,0  (of course)

	//Polygons inherit a radius from b2Shape. The radius creates a skin around the polygon. The skin is used in stacking scenarios to keep polygons slightly separated.
// This allows continuous collision to work against the core polygon.
//The polygon skin helps prevent tunneling by keeping the polygons separated. This results in small gaps between the shapes. Your visual representation can be larger than the polygon to hide any gaps.
	//polygon.Set(vertices, count);
//aH can accept points passed right in as args,
//or they can be wrapped in a single outer array
//the points can held in array or object,
//and are converted to array
//and the points are scaled down here as well