// The world class is used to drive the simulation. You specify a time step and a velocity and position iteration count. For example:
//
// float32 timeStep = 1.0f / 60.f;
//
// int32 velocityIterations = 10;
//
// int32 positionIterations = 8;
//
// myWorld.Step(timeStep, velocityIterations, positionIterations);
 
// After the time step you can examine your bodies and joints for information.
 Most likely you will grab the position off the bodies so that you can update your actors and render them. 
 You can perform the time step anywhere in your game loop, 
 		but you should be aware of the order of things. 
 For example, 
 		you must create bodies before the time step 
 					if you want to get collision results for the new bodies in that frame.



- you should use a fixed time step. 
	By using a larger time step,
			you can improve performance in low frame rate scenarios. 
	But generally,
		 you should use a time step no larger than 1/30 seconds. 
		 A time step of 1/60 seconds will usually deliver a high quality simulation.


 
// The iteration count controls how many times the constraint solver sweeps over all the contacts and joints in the world. 
More iteration always yields a better simulation. 
But don't trade a small time step for a large iteration count. 
60Hz and 10 iterations is far better than 30Hz and 20 iterations.


// After stepping, you should clear any forces you have applied to your bodies. 
This is done with the command b2World::ClearForces. 
This lets you take multiple sub-steps with the same force field.
 
// w.ClearForces();
	}
	
	function Exploring() {
// The world is a container for bodies, contacts, and joints. You can grab the body, contact, and joint lists 
off the world and iterate over them. 

For example, this code wakes up all the bodies in the world: for (b2Body* b = w.GBL(); b; b = b.GN()) { b.SetAwake(true) }

 Unfortunately real programs can be more complicated. For example, the following code is broken:
 for (b2Body* b = w.GBL(); b; b = b.GN()) {
	 GameActor* myActor = (GameActor*)b.GUD(); if (myActor.IsDead()) {	 w.DBd(b); }// ERROR: now GetNext returns garbage. }


 Everything goes ok until a body is destroyed. Once a body is destroyed, its next pointer becomes invalid. So the call to b2Body::GN() 
will return garbage. The solution to this is to copy the next pointer before destroying the body.
 
  b2Body* node = w.GBL();
  while (node)  {  b2Body* b = node;  node = node.GN(); GameActor* myActor = (GameActor*)b.GUD();
  if (myActor.IsDead())  {  w.DestroyBody(b);  }  }
//
// This safely destroys the current body.
However, you may want to call a game function that may destroy multiple bodies. 

In this case you need to be very careful. 
The solution is application specific,
	 but for convenience I'll show one method of solving the problem.


// b2Body* node = w.GBL();

	 while (node) { b2Body* b = node;  node = node.GN(); GameActor* myActor = (GameActor*)b.GUD();
// if (myActor.IsDead()) {otherBodiesDestroyed = GameCrazyBodyDestroyer(b);  if (otherBodiesDestroyed) { node = w.GBL(); } } }
// Obviously to make this work, GameCrazyBodyDestroyer must be honest about what it has destroyed.
	 