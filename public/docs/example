ex: Creating a Dynamic Body

So now we have a ground body. 
We can use the same technique to create a dynamic body. 
The main difference, besides dimensions, is that we must establish the dynamic body's mass properties.

First we create the body using CreateBody. 
By default bodies are static, so we should set the b2BodyType at construction time to make the body dynamic.

b2BodyDef bD;

bD.type = b2_dynamicBody;

bD.position.Set(0.0f, 4.0f);

b2Body* body = w.CB(&bD);

Caution:

You must set the body type to b2_dynamicBody if you want the body to move in response to forces.

Next we create and attach a polygon shape using a fixture definition. First we create a box shape:

b2PolygonShape dynamicBox;

dynamicBox.SetAsBox(1.0f, 1.0f);

Next we create a fixture definition using the box. Notice that we set density to 1. 
The default density is zero. Also, the friction on the shape is set to 0.3.

b2FixtureDef fD;

fD.H( &dynamicBox;).de(1.0f).fr(0.3f)
Using the fD we can now create the f. This automatically updates the mass of the b. 
You can add as many fs as you like to a b. Each one contributes to the total mass.
b.CF(&fD)

 Simulating the World (of Box2D):

So we have initialized the ground box and a dynamic box. 
Now we are ready to set Newton loose to do his thing.
 We just have a couple more issues to consider.

Box2D uses a computational algorithm called an integrator. 
Integrators simulate the physics equations at discrete points of time.
 This goes along with the traditional game loop where we essentially have a flip book of movement on the screen.
  So we need to pick a time step for Box2D. 
  Generally physics engines for games like a time step at least as fast as 60Hz or 1/60 seconds. 
  You can get away with larger time steps, 
  but you will have to be more careful about setting up the definitions for your world. 
  We also don't like the time step to change much.
   A variable time step produces variable results, which makes it difficult to debug.
   So don't tie the time step to your frame rate (unless you really, really have to).
    Without further ado, here is the time step.

float32 timeStep = 1.0f / 60.0f;

In addition to the integrator, Box2D also uses a larger bit of code called a constraint solver.
 The constraint solver solves all the constraints in the simulation, one at a time. 
 A single constraint can be solved perfectly. However, when we solve one constraint,
  we slightly disrupt other constraints. 
  To get a good solution, 
  we need to iterate over all constraints a number of times.

There are two phases in the constraint solver: a velocity phase and a position phase. In the velocity
 phase the solver computes the impulses necessary for the bodies to move correctly. In the position phase
  the solver adjusts the positions of the bodies to reduce overlap and joint detachment. 
  Each phase has its own 
  iteration count. 
  In addition, 
  	the position phase may exit iterations early if the errors are small.

The suggested iteration count for Box2D is 8 for velocity and 3 for position. 
You can tune this number to your liking, 
just keep in mind that this has a trade-off between speed and accuracy. 
Using fewer iterations increases performance but
 accuracy suffers. Likewise, using more iterations 
 decreases performance but improves the quality of your simulation. 
 For this simple example, we don't need much iteration. Here are our chosen iteration counts.

int32 velocityIterations = 6;

int32 positionIterations = 2;

Note that the time step and the iteration count are completely unrelated. 
An iteration is not a sub-step. One solver
 iteration is a single pass over all the constraints within a time step.
  You can have multiple passes over the constraints within a single time step.

We are now ready to begin the simulation loop. In your game the simulation loop can be merged with your game loop.
 In each pass through your game loop you call b2World::Step. Just one call is usually enough, depending
  on your frame rate and your physics time step.

The Hello World program was designed to be simple,
 so it has no graphical output. 
 	The code prints out the position
 and rotation of the dynamic body.
 		 Here is the simulation loop that simulates 60 time steps for a total of 1 second of simulated time.
for (int32 i = 0; i < 60; ++i){
    w.Step(timeStep, velocityIterations, positionIterations);
    b2Vec2 position = b.GetPosition();
    float32 angle = b.GetAngle();
    printf("%4.2f %4.2f %4.2f\n", position.x, position.y, angle);
}

The output shows the box falling and landing on the ground box. Your output should look like this:
0.00 4.00 0.00; 0.00 3.99 0.00; 0.00 3.98 0.00 ... 0.00 1.25 0.00; 0.00 1.13 0.00; 0.00 1.01 0.00

Cleanup:
When a world leaves scope or is deleted by calling delete on a pointer,
 all the memory reserved for bodies, fixtures, and joints is freed. 
This is done to improve performance and make your life easier. 
However, you will need to nullify any b,f, or j pointers you have because they will become invalid.
