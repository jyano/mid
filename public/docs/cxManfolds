
 // You can test two shapes for overlap using this function:

 xfA =b2Transform()//  …, xfB = …;

 overlap = b2TestOverlap(shapeA, indexA, shapeB, indexB, xfA, xfB);
 //
 // Again you must provide child indices to for the case of chain shapes.
 }
 function ContactManifolds() {
 //
 // Box2D has functions to compute contact points for overlapping shapes. If we consider circle-circle or circle-polygon,
 // we can only get one contact point and normal. In the case of polygon-polygon we can get two points.
 // These points share the same normal vector so Box2D groups them into a manifold structure.
 // The contact solver takes advantage of this to improve stacking stability.
 //
 //
 //
 // Normally you don’t need to compute contact manifolds directly, however you will likely use the results produced in the simulation.
 //
 // The b2Manifold structure holds a normal vector and up to two contact points.
 // The normal and points are held in local coordinates. As a convenience for the contact solver, 
 // each point stores the normal and tangential (friction) impulses.
 //
 // The data stored in b2Manifold is optimized for internal use.
 // If you need this data, it is usually best to use the b2WorldManifold structure
 // to generate the world coordinates of the contact normal and points. You need to provide a b2Manifold and the shape transforms and radii.


 // worldManifold = b2WorldManifold ()
 worldManifold.Initialize(&manifold, transformA, shapeA.m_radius, transformB, shapeB.m_radius);

 for (  i = 0; i < manifold.pointCount; ++i){point = worldManifold.points[i];}
 // During simulation shapes may move and the manifolds may change. 
 // Points may be added or removed. You can detect this using b2GetPointStates.

 state1[2]= b2PointState()

 state2[2] = b2PointState()
 //
 b2GetPointStates(state1, state2, &manifold1, &manifold2);
 //
 if (state1[0] == b2_removeState){  process event
 }
 }
 function manual() {
 function pointText() {
 // 4.7 In Shape Point Test
 //
 // You can test a point for overlap with a shape. You provide a transform for the shape and a world point.
 //
 // b2Transfrom transform;
 //
 // transform.SetIdentity();
 //
 // b2Vec2 point(5.0f, 2.0f);
 //
 // bool hit = shape->TestPoint(transform, point);
 //
 // Edge and chain shapes always return false, even if the chain is a loop.
 //